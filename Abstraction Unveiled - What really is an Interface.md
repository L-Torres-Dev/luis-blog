---
title: "Abstraction Unveiled: What really is an Interface?"
dg-publish: "false"
---
### Intro
A common way to explain the programmatic construct known as the `Interface` is to say that they are contracts that bind a class to a set of functions. So if you bind a `Dog` class to an `Animal` class that has functions like `Eat()` and `Speak()`, then that `Dog`class **must** implement both those methods. In the case of a dog, `Eat()` might involve eating dog food and `Speak()` would likely be a bark. Cats eat different food from a dog as well as “speak” differently so for `Eat()` it might eat a mouse, and `Speak()` would likely be a meow.

What I hate about this way of describing an interface is that this only really tells us _what_ an interface is and how it’s used at the surface level, but it speaks nothing of what they _really are_ at a deeper level and _why_ we use them. What’s worse, I am not kidding when I say this is often taught using the Dog-Cat and Animal analogy that isn’t even practical and doesn’t properly explain why we care about interfaces and abstraction. This always reminds me of how we are taught in high school of the mitochondria and how we’d simply regurgitate “The powerhouse of the cell” without actually knowing what “powerhouse” even means! Heck, I won’t pretend to know what it actually means, I have no idea! But I do at least know what an interface is, and I can explain it well beyond the simple definition of a “contract”. To understand what an interface is, we _first_ need to understand the general term of “Interface” and how it relates to abstraction in a practical sense.
### What is Abstraction

The Latin origin of the word “Abstraction” is “Abstrahere” which means to “Draw away from”. In a sense, whenever you create an abstraction, you’re drawing away from the specifics of a concretion and only holding on to the fundamental traits that give the concretion purpose. For example if you look at a stick, you might not think much of it at first until you need to reach for an object that is too far away. Now the stick is a tool that can be used to extend one’s reach. What you’ve done here is you’ve _Drawn away_ from the specifics of a “stick” and held onto only what you care about: “a long tool, useful for reaching for things”. Notice how you create this abstraction **only** when you need it. That stick might become a weapon you need to defend yourself if it happens to be heavy enough, in which case you’ve created a new abstraction. But a stick is not the only tool that can extend one’s reach nor is it the only thing that can be used as a weapon. A hammer can also extend your reach (it can also be a weapon), there is also the back scratcher, and even the ruler.

Put simply, an abstraction is a construct that defines a pattern among a group of more concrete constructs. Whenever you create an abstraction, you are effectively chunking a set of concrete constructs into a related group and often times, you give it a name. “Math” is an abstraction defined by a set of rules that involve numbers; I don’t have to explain what “Math” is to you because simply by saying it, your mind conjures up the concept holistically. Abstractions give humans a common language by which we communicate and interact with the world. I like to simplify the uses of abstraction to 3 basic use cases:
1. To chunk complexity into a single entity/symbol/name to make it easier to understand and work with
2. To swap between different implementations of the given abstraction as needed
3. To defer an important design decision for later

I’ve already given you examples of numbers 1 and 2. Number 1 was the “math” example and number 2 was the “stick” example being replaceable with a hammer, or a ruler or a backscratcher because all of these things are things that can extend your reach. The best real world example of number 3 is the Outlet (although, this is also an example of number 2) that people use to plug many different kinds of devices to. You can plug your toaster, your cellphone and even a computer to it and it all _just works_. We created outlets to _defer_ the overall use of a house to the homeowner. Because the house is effectively an empty shell with a bunch of outlets, the homeowner can customize the functionality of their house with whatever they want that requires power. If you want a TV, you can buy one and plug it into one of the outlets in your house. If you want different colored lights in one of your rooms, you can do so with the outlet. The builders who built your home didn’t have to do any of that for you, and they shouldn’t. You _should_ be able to use your home however you want, and so the builders defer those decisions to you, the owner.

This is important to understand as we dive deeper into interfaces in general.